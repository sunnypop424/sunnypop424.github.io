{"version":3,"file":"static/js/290.5d94d426.chunk.js","mappings":"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","sources":["lib/optimizerCore.js","workers/optimizer.worker.js"],"sourcesContent":["// src/lib/optimizerCore.js\r\n/* =============================== 타입(주석용 정의) =============================== */\r\n/** @typedef {\"dealer\"|\"support\"} Role */\r\n/** @typedef {\"atk\"|\"add\"|\"boss\"|\"brand\"|\"allyDmg\"|\"allyAtk\"} OptionKey */\r\n/** @typedef {\"HERO\"|\"LEGEND\"|\"RELIC\"|\"ANCIENT\"} CoreGrade */\r\n/** @typedef {{id:string, will:number|null, point:number|null, o1k:OptionKey, o1v:number|null, o2k:OptionKey, o2v:number|null}} Gem */\r\n/** @typedef {{[k in OptionKey]: number}} Weights */\r\n/** @typedef {{ id:string, name:string, grade:CoreGrade, minThreshold?:number, enforceMin:boolean }} CoreDef */\r\n/** @typedef {{ list: Gem[], totalWill:number, totalPoint:number, thr:number[], roleSum:number, score:number }} ComboInfo */\r\n\r\n/* =============================== 상수 정의 =============================== */\r\nexport const CORE_SUPPLY = { HERO: 7, LEGEND: 11, RELIC: 15, ANCIENT: 17 };\r\nexport const CORE_THRESHOLDS = {\r\n  HERO: [10],\r\n  LEGEND: [10, 14],\r\n  RELIC: [10, 14, 17, 18, 19, 20],\r\n  ANCIENT: [10, 14, 17, 18, 19, 20],\r\n};\r\nexport const CORE_LABEL = { HERO: \"영웅\", LEGEND: \"전설\", RELIC: \"유물\", ANCIENT: \"고대\" };\r\nexport const GRADES = [\"HERO\", \"LEGEND\", \"RELIC\", \"ANCIENT\"];\r\nexport const OPTION_LABELS = {\r\n  atk: \"공격력\",\r\n  add: \"추가 피해\",\r\n  boss: \"보스 피해\",\r\n  brand: \"낙인력\",\r\n  allyDmg: \"아군 피해 강화\",\r\n  allyAtk: \"아군 공격 강화\",\r\n};\r\nexport const OPTIONS = [\"atk\", \"add\", \"boss\", \"brand\", \"allyDmg\", \"allyAtk\"];\r\nexport const ROLE_KEYS = {\r\n  dealer: new Set([\"atk\", \"add\", \"boss\"]),\r\n  support: new Set([\"brand\", \"allyDmg\", \"allyAtk\"]),\r\n};\r\nexport const DEFAULT_WEIGHTS = { atk: 1, add: 1, boss: 1, brand: 1, allyDmg: 1, allyAtk: 1 };\r\n// 딜러 가중치: y ≈ slope * level (원점 통과 회귀 추정)\r\nexport const DEALER_WEIGHTS = {\r\n  boss: 0.07870909,\r\n  add: 0.06018182,\r\n  atk: 0.03407273,\r\n  brand: 0,\r\n  allyDmg: 0,\r\n  allyAtk: 0,\r\n};\r\n\r\n/* =============================== 유틸/헬퍼 =============================== */\r\nexport function sanitizeWeights(w) {\r\n  const base = { ...DEFAULT_WEIGHTS };\r\n  if (!w) return base;\r\n  Object.keys(base).forEach((k) => {\r\n    const raw = w[k];\r\n    const num = typeof raw === 'number' ? raw : Number(raw);\r\n    base[k] = Number.isFinite(num) && num >= 0 ? num : DEFAULT_WEIGHTS[k];\r\n  });\r\n  return /** @type {Weights} */(base);\r\n}\r\nexport function scoreGemForRole(g, role, w) {\r\n  if (role == null) return 0; // 역할 미선택이면 유효옵션 점수 0\r\n  const keys = role === \"dealer\" ? ROLE_KEYS.dealer : ROLE_KEYS.support;\r\n  const s1 = keys.has(g.o1k) ? (g.o1v ?? 0) * (w[g.o1k] ?? 1) : 0;\r\n  const s2 = keys.has(g.o2k) ? (g.o2v ?? 0) * (w[g.o2k] ?? 1) : 0;\r\n  return s1 + s2;\r\n}\r\nexport function* combinations(arr, k) {\r\n  const n = arr.length; if (k > n) return;\r\n  const idx = Array.from({ length: k }, (_, i) => i);\r\n  while (true) {\r\n    yield idx.map(i => arr[i]);\r\n    let p = k - 1;\r\n    while (p >= 0 && idx[p] === n - k + p) p--;\r\n    if (p < 0) break;\r\n    idx[p]++;\r\n    for (let j = p + 1; j < k; j++) idx[j] = idx[j - 1] + 1;\r\n  }\r\n}\r\nexport function thresholdsHit(grade, totalPoint) {\r\n  const th = CORE_THRESHOLDS[grade];\r\n  return th.filter(t => totalPoint >= t);\r\n}\r\nexport function scoreCombo(combo, grade, role, weights) {\r\n  const totalWill = combo.reduce((s, g) => s + ((g.will ?? 0)), 0);\r\n  const totalPoint = combo.reduce((s, g) => s + ((g.point ?? 0)), 0);\r\n  const thr = thresholdsHit(grade, totalPoint);\r\n  const roleSum = combo.reduce((s, g) => s + scoreGemForRole(g, role, weights), 0);\r\n  const score = (thr.length * 10_000_000)\r\n              + (totalPoint * 10_000)\r\n              + ((5_000 - totalWill) * 10)\r\n              + roleSum\r\n              - combo.length;\r\n  return { totalWill, totalPoint, thr, roleSum, score };\r\n}\r\n/* 단일 코어 후보 산출 (통일 정책: 달성 구간이 없으면 결과 없음) */\r\nexport function enumerateCoreCombos(pool, grade, role, weights, minThreshold, enforceMin, onStep) {\r\n  const supply = CORE_SUPPLY[grade];\r\n  const W = sanitizeWeights(weights);\r\n  const minOfGrade = Math.min(...CORE_THRESHOLDS[grade]);\r\n  const effMin = minThreshold ?? minOfGrade;\r\n  const effEnforce = enforceMin || minThreshold == null;\r\n  /** @type {ComboInfo[]} */\r\n  const all = [];\r\n  const maxPick = Math.min(4, pool.length);\r\n  for (let k = 0; k <= maxPick; k++) {\r\n    if (k === 0) { all.push({ list: [], totalWill: 0, totalPoint: 0, thr: [], roleSum: 0, score: 0 }); continue; }\r\n    for (const combo of combinations(pool, k)) {\r\n      onStep && onStep(1); // 콤보 하나 평가 시작(진행률 카운트)\r\n      const totalWill = combo.reduce((s, g) => s + (g.will || 0), 0);\r\n      if (totalWill > supply) continue;\r\n      const { totalPoint, thr, roleSum, score } = scoreCombo(combo, grade, role, W);\r\n      all.push({ list: combo, totalWill, totalPoint, thr, roleSum, score });\r\n    }\r\n  }\r\n  all.sort((a, b) => b.score - a.score);\r\n  let filtered;\r\n  if (effEnforce) {\r\n    filtered = all.filter(ci => {\r\n      const maxThr = Math.max(0, ...ci.thr);\r\n      return ci.list.length > 0 && maxThr >= (effMin ?? 0);\r\n    });\r\n  } else {\r\n    filtered = all.filter(ci => ci.list.length > 0 && ci.thr.length > 0);\r\n  }\r\n  if (filtered.length === 0) {\r\n    return [{ list: [], totalWill: 0, totalPoint: 0, thr: [], roleSum: 0, score: 0 }];\r\n  }\r\n  return filtered;\r\n}\r\n/* ===== 전역 최적 배치: thr 합 최대(1순위) + 강제는 하한(≥min) + 우선순위 사전식 ===== */\r\nexport function optimizeRoundRobinTargets(cores, pool, role, weights, perCoreLimit = 300) {\r\n  const W = sanitizeWeights(weights);\r\n  const thresholdsOf = (grade) => CORE_THRESHOLDS[grade];\r\n  const minOf = (grade) => Math.min(...thresholdsOf(grade));\r\n  const thrMax = (ci) => (ci?.thr?.length ? Math.max(...ci.thr) : 0);\r\n\r\n  const emptyPick = { list: [], totalWill: 0, totalPoint: 0, thr: [], roleSum: 0, score: 0 };\r\n\r\n  // 표시 우선순위(위→아래)\r\n  const order = cores.map((_, i) => i);\r\n  const enforcedIdx = cores.map((c, i) => (c.enforceMin ? i : -1)).filter(i => i !== -1);\r\n\r\n  const candidatesFor = (core, gemPool) => {\r\n    const arr = enumerateCoreCombos(gemPool, core.grade, role, W, undefined, false)\r\n      .filter(ci => ci.list.length > 0 && ci.thr.length > 0);\r\n    arr.sort((a, b) => {\r\n      const ta = thrMax(a), tb = thrMax(b);\r\n      if (ta !== tb) return tb - ta;\r\n      if (a.totalPoint !== b.totalPoint) return b.totalPoint - a.totalPoint;\r\n      if (a.roleSum !== b.roleSum) return b.roleSum - a.roleSum; // 유효합 우선\r\n      return a.totalWill - b.totalWill;\r\n    });\r\n    return arr.slice(0, Math.max(perCoreLimit, 10000));\r\n  };\r\n\r\n  const allCandidates = order.map(i => candidatesFor(cores[i], pool));\r\n\r\n  function betterThan(A, B) {\r\n    if (!B) return true;\r\n    if (A.sumThr !== B.sumThr) return A.sumThr > B.sumThr;\r\n    for (let i = 0; i < A.thrVec.length; i++) {\r\n      if (A.thrVec[i] !== B.thrVec[i]) return A.thrVec[i] > B.thrVec[i];\r\n    }\r\n    if (A.sumPoint !== B.sumPoint) return A.sumPoint > B.sumPoint;\r\n    for (let i = 0; i < A.ptVec.length; i++) {\r\n      if (A.ptVec[i] !== B.ptVec[i]) return A.ptVec[i] > B.ptVec[i];\r\n    }\r\n    if (A.roleSum !== B.roleSum) return A.roleSum > B.roleSum; // 유효합 더 큰 쪽\r\n    if (A.sumWill !== B.sumWill) return A.sumWill < B.sumWill; // 의지력 적을수록 우위\r\n    return false;\r\n  }\r\n\r\n  // ---- 공통 백트래킹: 주어진 enforceSet에 대해 최적해 탐색 ----\r\n  function trySolve(enforceSet, blockedSet = new Set()) {\r\n    let best = null;\r\n    const used = new Set();\r\n\r\n    function backtrack(pos, picksAcc, sumThrAcc, sumPointAcc, sumWillAcc, roleSumAcc, thrVec, ptVec) {\r\n      if (pos === order.length) {\r\n        // 강제 코어 하한 검사\r\n        for (const idx of enforceSet) {\r\n          const effMin = (cores[idx].minThreshold ?? minOf(cores[idx].grade));\r\n          const t = thrMax(picksAcc[idx]);\r\n          if (t < effMin) return;\r\n        }\r\n        const cand = {\r\n          picks: picksAcc.map(x => x),\r\n          sumThr: sumThrAcc,\r\n          sumPoint: sumPointAcc,\r\n          sumWill: sumWillAcc,\r\n          roleSum: roleSumAcc,\r\n          thrVec: thrVec.slice(),\r\n          ptVec: ptVec.slice(),\r\n        };\r\n        if (betterThan(cand, best)) best = cand;\r\n        return;\r\n      }\r\n\r\n      const coreIdx = order[pos];\r\n      const isEnf = enforceSet.has(coreIdx);\r\n      const effMin = isEnf ? (cores[coreIdx].minThreshold ?? minOf(cores[coreIdx].grade)) : -Infinity;\r\n\r\n      // 차단 코어는 empty만 허용\r\n      if (blockedSet.has(coreIdx)) {\r\n        backtrack(pos + 1, picksAcc, sumThrAcc, sumPointAcc, sumWillAcc, roleSumAcc, thrVec, ptVec);\r\n        return;\r\n      }\r\n\r\n      const candList = allCandidates[pos];\r\n\r\n      // 후보 시도\r\n      for (const pick of candList) {\r\n        const t = thrMax(pick);\r\n        if (isEnf && t < effMin) continue;\r\n\r\n        // 젬 충돌\r\n        let clash = false;\r\n        for (const g of pick.list) { if (used.has(g.id)) { clash = true; break; } }\r\n        if (clash) continue;\r\n\r\n        pick.list.forEach(g => used.add(g.id));\r\n        const prev = picksAcc[coreIdx];\r\n        picksAcc[coreIdx] = pick;\r\n\r\n        thrVec[pos] = t;\r\n        ptVec[pos] = pick.totalPoint;\r\n\r\n        backtrack(\r\n          pos + 1,\r\n          picksAcc,\r\n          sumThrAcc + t,\r\n          sumPointAcc + pick.totalPoint,\r\n          sumWillAcc + pick.totalWill,\r\n          roleSumAcc + pick.roleSum,\r\n          thrVec,\r\n          ptVec\r\n        );\r\n\r\n        // 롤백\r\n        pick.list.forEach(g => used.delete(g.id));\r\n        picksAcc[coreIdx] = prev;\r\n        thrVec[pos] = 0;\r\n        ptVec[pos] = 0;\r\n      }\r\n\r\n      // 비강제는 빈 선택 허용\r\n      if (!isEnf) {\r\n        backtrack(pos + 1, picksAcc, sumThrAcc, sumPointAcc, sumWillAcc, roleSumAcc, thrVec, ptVec);\r\n      }\r\n    }\r\n\r\n    backtrack(\r\n      0,\r\n      cores.map(() => emptyPick),\r\n      0, 0, 0, 0,\r\n      Array(order.length).fill(0),\r\n      Array(order.length).fill(0)\r\n    );\r\n\r\n    return best; // null(실패) 또는 최적해\r\n  }\r\n\r\n  // 1) 원래 로직(강제 전부 지킴) 우선 시도\r\n  const enforcedSetFull = new Set(enforcedIdx);\r\n  const bestFull = trySolve(enforcedSetFull);\r\n  if (bestFull) {\r\n    return { picks: bestFull.picks };\r\n  }\r\n\r\n  // 1.5) 전역해가 없으면: 최하 코어를 차단하고 재시도\r\n  if (order.length > 0) {\r\n    const lowestIdx = order[order.length - 1];\r\n    const enforcedMinusLowest = new Set([...enforcedSetFull].filter(i => i !== lowestIdx));\r\n    const bestDropLowest = trySolve(enforcedMinusLowest, new Set([lowestIdx]));\r\n    if (bestDropLowest) {\r\n      const finalPicks = bestDropLowest.picks.map((p, i) => (i === lowestIdx ? emptyPick : (p || emptyPick)));\r\n      return { picks: finalPicks };\r\n    }\r\n  }\r\n\r\n  // 2) 강제 불가능 판별\r\n  const infeasibleEnforced = new Set();\r\n  for (const idx of enforcedIdx) {\r\n    const effMin = (cores[idx].minThreshold ?? minOf(cores[idx].grade));\r\n    const pos = order.indexOf(idx);\r\n    const hasFeasible = (allCandidates[pos] || []).some(ci => thrMax(ci) >= effMin);\r\n    if (!hasFeasible) infeasibleEnforced.add(idx);\r\n  }\r\n\r\n  // 3) 가능한 강제만 유지하고 다시 최적화\r\n  const enforcedSetReduced = new Set(enforcedIdx.filter(i => !infeasibleEnforced.has(i)));\r\n  const bestReduced = trySolve(enforcedSetReduced);\r\n\r\n  if (bestReduced) {\r\n    // 4) 최종 출력에서 \"실제로 불가능했던 강제 코어\"만 결과없음 처리\r\n    const finalPicks = bestReduced.picks.map((p, i) => (infeasibleEnforced.has(i) ? emptyPick : (p || emptyPick)));\r\n    return { picks: finalPicks };\r\n  }\r\n\r\n  // 5) 그래도 실패 시 안전망\r\n  return { picks: cores.map(() => emptyPick) };\r\n}\r\n","// src/workers/optimizer.worker.js\r\n/* eslint-env worker, es2020 */\r\nimport { enumerateCoreCombos, CORE_THRESHOLDS, sanitizeWeights } from \"../lib/optimizerCore.js\";\r\n\r\nconst thrMax = (ci) => (ci?.thr?.length ? Math.max(...ci.thr) : 0);\r\nconst minOf = (g) => Math.min(...CORE_THRESHOLDS[g]);\r\nconst now = () => (globalThis.performance?.now?.() ?? Date.now());\r\n\r\nfunction clash(pick, usedSet) {\r\n  for (const g of pick.list) if (usedSet.has(g.id)) return true;\r\n  return false;\r\n}\r\n\r\n// emit을 너무 자주 보내지 않도록 간단 throttle\r\nfunction makeThrottledEmit(emit, minMs = 8) {\r\n  let last = 0;\r\n  return (payload, force = false) => {\r\n    const t = now();\r\n    if (force || t - last >= minMs) {\r\n      last = t;\r\n      emit(payload);\r\n    }\r\n  };\r\n}\r\n\r\nfunction buildAllCandidates({ cores, pool, role, weights, perCoreLimit, emitOverall }) {\r\n  const n = pool.length;\r\n  const maxPick = Math.min(4, n);\r\n  const nCk = (N, K) => {\r\n    let c = 1; for (let i = 1; i <= K; i++) c = (c * (N - i + 1)) / i;\r\n    return Math.floor(c);\r\n  };\r\n  const totalCombos = Array.from({ length: maxPick }, (_, i) => nCk(n, i + 1)).reduce((a, b) => a + b, 0);\r\n\r\n  let doneCombos = 0;\r\n  const candidatesPerCore = cores.map((core) => {\r\n    const list = enumerateCoreCombos(\r\n      pool, core.grade, role, weights, undefined, false,\r\n      () => { doneCombos += 1; } // ✅ 내부 카운트만 누적\r\n    )\r\n      .filter((ci) => ci.list.length > 0 && ci.thr.length > 0)\r\n      .sort((a, b) => {\r\n        const ta = thrMax(a), tb = thrMax(b);\r\n        if (ta !== tb) return tb - ta;\r\n        if (a.totalPoint !== b.totalPoint) return b.totalPoint - a.totalPoint;\r\n        if (a.roleSum !== b.roleSum) return b.roleSum - a.roleSum;\r\n        return a.totalWill - b.totalWill;\r\n      })\r\n      .slice(0, Math.max(perCoreLimit, 10000));\r\n\r\n    // ⚠️ 여기서는 emit 안 함(“후보 단계가 번쩍”하는 문제 방지)\r\n    // doneCombos는 누적돼 있고, 전체 total을 알게 된 뒤 한꺼번에 반영한다.\r\n    return list;\r\n  });\r\n\r\n  return { candidatesPerCore, totalCombos, doneCombos };\r\n}\r\n\r\nfunction countSearchNodes({ cores, order, enforcedSet, candidatesPerCore }) {\r\n  let total = 0;\r\n  const used = new Set();\r\n\r\n  (function dfs(pos) {\r\n    if (pos === order.length) return;\r\n    const coreIdx = order[pos];\r\n    const isEnf = enforcedSet.has(coreIdx);\r\n    const effMin = isEnf ? (cores[coreIdx].minThreshold ?? minOf(cores[coreIdx].grade)) : -Infinity;\r\n    const list = candidatesPerCore[coreIdx];\r\n\r\n    for (const pick of list) {\r\n      const t = thrMax(pick);\r\n      if (isEnf && t < effMin) continue;\r\n      if (clash(pick, used)) continue;\r\n      total += 1; // 시도 노드\r\n      pick.list.forEach((g) => used.add(g.id));\r\n      dfs(pos + 1);\r\n      pick.list.forEach((g) => used.delete(g.id));\r\n    }\r\n    if (!isEnf) { total += 1; dfs(pos + 1); } // 빈 선택 시도\r\n  })(0);\r\n\r\n  return total;\r\n}\r\n\r\nfunction solveWithUnifiedProgress({ cores, pool, role, weights, perCoreLimit, emit }) {\r\n  const order = cores.map((_, i) => i);\r\n  const enforcedSet = new Set(cores.map((c, i) => (c.enforceMin ? i : -1)).filter((i) => i !== -1));\r\n  const throttled = makeThrottledEmit(emit, 8);\r\n\r\n  // 1) 후보 생성 (내부 카운트만)\r\n  const { candidatesPerCore, totalCombos, doneCombos } = buildAllCandidates({\r\n    cores, pool, role, weights, perCoreLimit, emitOverall: throttled,\r\n  });\r\n\r\n  // 2) 전체 작업량 확정: combos + search\r\n  const totalSearch = countSearchNodes({ cores, order, enforcedSet, candidatesPerCore });\r\n  const totalAll = totalCombos + totalSearch;\r\n\r\n  // 후보 단계까지의 누적을 **정확하게** 한 번 반영\r\n  throttled({\r\n    type: \"progress\",\r\n    label: \"후보 생성 정리 중…\",\r\n    done: doneCombos,\r\n    total: totalAll,\r\n  }, true);\r\n\r\n  // 3) 실제 탐색 + 진행률 (정확)\r\n  const emptyPick = { list: [], totalWill: 0, totalPoint: 0, thr: [], roleSum: 0, score: 0 };\r\n  const betterThan = (A, B) => {\r\n    if (!B) return true;\r\n    if (A.sumThr !== B.sumThr) return A.sumThr > B.sumThr;\r\n    for (let i = 0; i < A.thrVec.length; i++) if (A.thrVec[i] !== B.thrVec[i]) return A.thrVec[i] > B.thrVec[i];\r\n    if (A.sumPoint !== B.sumPoint) return A.sumPoint > B.sumPoint;\r\n    for (let i = 0; i < A.ptVec.length; i++) if (A.ptVec[i] !== B.ptVec[i]) return A.ptVec[i] > B.ptVec[i];\r\n    if (A.roleSum !== B.roleSum) return A.roleSum > B.roleSum;\r\n    if (A.sumWill !== B.sumWill) return A.sumWill < B.sumWill;\r\n    return false;\r\n  };\r\n\r\n  let best = null;\r\n  const used = new Set();\r\n  let doneSearch = 0;\r\n\r\n  (function dfs(pos, picksAcc, thrVec, ptVec) {\r\n    if (pos === order.length) return;\r\n    const coreIdx = order[pos];\r\n    const isEnf = enforcedSet.has(coreIdx);\r\n    const effMin = isEnf ? (cores[coreIdx].minThreshold ?? minOf(cores[coreIdx].grade)) : -Infinity;\r\n    const list = candidatesPerCore[coreIdx];\r\n\r\n    for (const pick of list) {\r\n      const t = thrMax(pick);\r\n      if (isEnf && t < effMin) continue;\r\n      if (clash(pick, used)) continue;\r\n\r\n      doneSearch += 1;\r\n      throttled({ type: \"progress\", label: \"최적 배치 탐색 중…\", done: doneCombos + doneSearch, total: totalAll });\r\n\r\n      pick.list.forEach((g) => used.add(g.id));\r\n      const prev = picksAcc[coreIdx]; picksAcc[coreIdx] = pick;\r\n      thrVec[pos] = t; ptVec[pos] = pick.totalPoint;\r\n\r\n      if (pos + 1 === order.length) {\r\n        let feasible = true;\r\n        enforcedSet.forEach((idx) => {\r\n          const m = thrMax(picksAcc[idx]);\r\n          const minThr = cores[idx].minThreshold ?? minOf(cores[idx].grade);\r\n          if (m < minThr) feasible = false;\r\n        });\r\n        if (feasible) {\r\n          const cand = {\r\n            picks: picksAcc.map((x) => x || emptyPick),\r\n            sumThr: thrVec.reduce((a, b) => a + b, 0),\r\n            sumPoint: ptVec.reduce((a, b) => a + b, 0),\r\n            sumWill: picksAcc.reduce((s, p) => s + (p?.totalWill || 0), 0),\r\n            roleSum: picksAcc.reduce((s, p) => s + (p?.roleSum || 0), 0),\r\n            thrVec: thrVec.slice(),\r\n            ptVec: ptVec.slice(),\r\n          };\r\n          if (betterThan(cand, best)) best = cand;\r\n        }\r\n      } else {\r\n        dfs(pos + 1, picksAcc, thrVec, ptVec);\r\n      }\r\n\r\n      pick.list.forEach((g) => used.delete(g.id));\r\n      picksAcc[coreIdx] = prev;\r\n      thrVec[pos] = 0; ptVec[pos] = 0;\r\n    }\r\n\r\n    if (!isEnf) {\r\n      doneSearch += 1;\r\n      throttled({ type: \"progress\", label: \"최적 배치 탐색 중…\", done: doneCombos + doneSearch, total: totalAll });\r\n      if (pos + 1 === order.length) {\r\n        const cand = {\r\n          picks: picksAcc.map((x) => x || emptyPick),\r\n          sumThr: thrVec.reduce((a, b) => a + b, 0),\r\n          sumPoint: ptVec.reduce((a, b) => a + b, 0),\r\n          sumWill: picksAcc.reduce((s, p) => s + (p?.totalWill || 0), 0),\r\n          roleSum: picksAcc.reduce((s, p) => s + (p?.roleSum || 0), 0),\r\n          thrVec: thrVec.slice(),\r\n          ptVec: ptVec.slice(),\r\n        };\r\n        if (betterThan(cand, best)) best = cand;\r\n      } else {\r\n        dfs(pos + 1, picksAcc, thrVec, ptVec);\r\n      }\r\n    }\r\n  })(0, cores.map(() => emptyPick), Array(order.length).fill(0), Array(order.length).fill(0));\r\n\r\n  return { picks: best ? best.picks : cores.map(() => emptyPick) };\r\n}\r\n\r\nglobalThis.onmessage = (e) => {\r\n  const { cores, gems, role, weights, perCoreLimit } = e.data;\r\n  const emit = (msg) => globalThis.postMessage(msg);\r\n\r\n  try {\r\n    // 준비 알림(선택)\r\n    emit({ type: \"progress\", label: \"준비 중…\", done: 0, total: 1 });\r\n\r\n    const result = solveWithUnifiedProgress({\r\n      cores,\r\n      pool: gems,\r\n      role,\r\n      weights: sanitizeWeights(weights),\r\n      perCoreLimit,\r\n      emit,\r\n    });\r\n\r\n    emit({ type: \"result\", ...result });\r\n  } catch (err) {\r\n    emit({ type: \"error\", error: String(err?.message || err) });\r\n  }\r\n};\r\n"],"names":["CORE_SUPPLY","HERO","LEGEND","RELIC","ANCIENT","CORE_THRESHOLDS","ROLE_KEYS","dealer","Set","support","DEFAULT_WEIGHTS","atk","add","boss","brand","allyDmg","allyAtk","sanitizeWeights","w","base","Object","keys","forEach","k","raw","num","Number","isFinite","combinations","arr","n","length","idx","Array","from","_","i","map","p","j","scoreCombo","combo","grade","role","weights","totalWill","reduce","s","g","_g$will","will","totalPoint","_g$point","point","thr","filter","t","thresholdsHit","roleSum","_g$o1v","_w$g$o1k","_g$o2v","_w$g$o2k","has","o1k","o1v","o2k","o2v","scoreGemForRole","score","enumerateCoreCombos","pool","minThreshold","enforceMin","onStep","supply","W","minOfGrade","Math","min","effMin","effEnforce","all","maxPick","push","list","filtered","sort","a","b","ci","maxThr","max","thrMax","_ci$thr","minOf","clash","pick","usedSet","id","makeThrottledEmit","emit","minMs","arguments","undefined","last","payload","force","now","_globalThis$performan","_globalThis$performan2","_globalThis$performan3","globalThis","performance","call","Date","buildAllCandidates","_ref","cores","perCoreLimit","emitOverall","totalCombos","nCk","N","K","c","floor","doneCombos","candidatesPerCore","core","ta","tb","slice","solveWithUnifiedProgress","_ref3","order","enforcedSet","throttled","totalSearch","_ref2","total","used","dfs","pos","_cores$coreIdx$minThr","coreIdx","isEnf","delete","countSearchNodes","totalAll","type","label","done","emptyPick","betterThan","A","B","sumThr","thrVec","sumPoint","ptVec","sumWill","best","doneSearch","picksAcc","_cores$coreIdx$minThr2","Infinity","prev","feasible","_cores$idx$minThresho","cand","picks","x","fill","onmessage","e","gems","data","msg","postMessage","err","error","String","message"],"sourceRoot":""}